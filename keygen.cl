/**
 * Generate key space on GPU as they are consumed, maybe its better than
 * storing them in a GPU buffer generated by another kernel.
 */
#include "kernel.h"

#if KEYGEN_USE_PRIVATE_MEM
    #define KEYGEN_LOCAL
#else
    #define KEYGEN_LOCAL __local
#endif

void maskedKey(
    KEYGEN_LOCAL uint key[MASK_KEY_INTS],
    KEYGEN_LOCAL uint counters[MASK_KEY_CHARS],
    ulong index,
    __constant const struct CLString mask[MASK_KEY_CHARS])
{
    // initialize a key from its position in the key space (index)
    // subsequent keys generated via nextMaskedKey()
    KEYGEN_LOCAL char* ch=(KEYGEN_LOCAL char*)key;

    for (int i = MASK_KEY_CHARS-1; i >=0 ; --i)
    {
        uchar base = mask[i].len;
        uchar digit = index % base;
        counters[i] = digit;
        index /= base;
        
        ch[i] = mask[i].ch[digit];        
    }
}

void nextMaskedKey(
    KEYGEN_LOCAL uint key[MASK_KEY_INTS],
    KEYGEN_LOCAL uint counters[MASK_KEY_CHARS],
    __constant const struct CLString mask[MASK_KEY_CHARS])
{
    KEYGEN_LOCAL char* ch = (KEYGEN_LOCAL char*)key;
    
    // use separate increment function to avoid % and /
    for (int i = MASK_KEY_CHARS-1; i >= 0; --i)
    {
        uchar digit = (counters[i]+1) & 0xff;
        if (digit < mask[i].len)
        {
            ch[i] = mask[i].ch[digit];
            counters[i] = digit;
            break;
        }
        else
        {
            ch[i] = mask[i].ch[0];
            counters[i] = 0;
        }
    }
}

__kernel void keygen(
    __global uint* keys, // output
    const ulong sequenceIndex, // position in keyspace
    __constant const struct CLString mask[MASK_KEY_CHARS] // MASK_KEY_MASK => CLString[]
#if !KEYGEN_USE_PRIVATE_MEM
    , __local uint* scratch // temporary for key gen
#endif
    )
{
#if KEYGEN_USE_PRIVATE_MEM
    uint key[MASK_KEY_INTS];
    uint counters[MASK_COUNTER_INTS];
#else
    __local uint* key = (__local uint*)(scratch + (MASK_KEY_INTS+MASK_COUNTER_INTS)*get_local_id(0));
    __local uint* counters = (__local uint*)(key + MASK_KEY_INTS);
#endif

    const uint iterations = get_local_size(0);
    const uint outOffset = get_global_id(0)*iterations;

    ulong index = sequenceIndex;
    index += outOffset;
    keys += outOffset*MASK_KEY_INTS;
    
    maskedKey(key, counters, index, mask);

    for (uint j = 0; j < iterations; j++)
    {
        for (uint i = 0; i < MASK_KEY_INTS; i++)
            keys[i] = key[i];
        
        nextMaskedKey(key, counters, mask);
        
        keys += MASK_KEY_INTS;
    }
}
