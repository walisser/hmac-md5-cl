/**
 * Generate key space on GPU as they are consumed, would seem better than
 * storing them in a GPU buffer generated by another kernel since the
 * key can reside in private or local memory.
 */
#include "kernel.h"

#if KEYGEN_USE_PRIVATE_MEM
    #define KEYGEN_LOCAL
#else
    #define KEYGEN_LOCAL __local
#endif

// stateless key generation
void singleKey(
    KEYGEN_LOCAL uint key[MASK_KEY_INTS],
    ulong index,
    __constant const struct CLString mask[MASK_KEY_CHARS])
{
    KEYGEN_LOCAL char* ch=(KEYGEN_LOCAL char*)key;

    for (int i = MASK_KEY_CHARS-1; i >=0 ; --i)
    {
        uchar base = mask[i].len;
        uchar digit = index % base;
        index /= base;
        ch[i] = mask[i].ch[digit];
    }
}

// initialize a key from its position in the key space (index)
// subsequent keys generated via nextMaskedKey()
void maskedKey(
    KEYGEN_LOCAL uint key[MASK_KEY_INTS],
    KEYGEN_LOCAL uchar counters[MASK_KEY_CHARS],
    ulong index,
    __constant const struct CLString mask[MASK_KEY_CHARS])
{
    KEYGEN_LOCAL char* ch=(KEYGEN_LOCAL char*)key;

    for (int i = MASK_KEY_CHARS-1; i >= 0; --i)
    {
        uchar base = mask[i].len;
        uchar digit = index % base;
        counters[i] = digit;
        index /= base;
        ch[i] = mask[i].ch[digit];
    }
}

// use separate increment function to avoid % and /,
// and avoid touching the unchanged msb
void nextMaskedKey(
    KEYGEN_LOCAL uint key[MASK_KEY_INTS],
    KEYGEN_LOCAL uchar counters[MASK_KEY_CHARS],
    __constant const struct CLString mask[MASK_KEY_CHARS])
{
    KEYGEN_LOCAL char* ch = (KEYGEN_LOCAL char*)key;

    // testing removal of break statement, but slower
#if 0
    uchar done = (uchar)0;
    for (int i = MASK_KEY_CHARS-1; i >= 0; --i)
    {
//        if (done)
//            break;

        uchar digit = counters[i];
        if (!done)
        {
            digit++;

            // branchless wrap, but performs about the same
            // this may mean it is pointless to run multiple
            // loops per item (LOOP_COUNT > 1)
//            uchar diff = mask[i].len - digit;
//            uchar wrap = clamp(diff, (uchar)0, (uchar)1);
//            ctr *= wrap;
//            done = wrap;

            if (digit < mask[i].len)
                done = true;
            else
                digit = 0;

            counters[i] = digit;

        }
        ch[i] = mask[i].ch[digit];
    }
#else
    for (int i = MASK_KEY_CHARS-1; i >= 0; --i)
    {
        uchar maskIndex = (counters[i]+1) & 0xff;
        if (maskIndex < mask[i].len)
        {
            counters[i] = maskIndex;
            ch[i] = mask[i].ch[maskIndex];
            break;
        }
        else
        {
            counters[i] = 0;
            ch[i] = mask[i].ch[0];
        }
    }
 #endif
}

// testing
__kernel void keygen(
    __global uint* keys,       // output
    const ulong sequenceIndex, // position in keyspace
    __constant const struct CLString mask[MASK_KEY_CHARS] // MASK_KEY_MASK => CLString[]
#if !KEYGEN_USE_PRIVATE_MEM
    , __local uint* scratch // temporary for key gen
#endif
    )
{
#if KEYGEN_USE_PRIVATE_MEM
    uint key[MASK_KEY_INTS];
    uchar counters[MASK_KEY_CHARS];
#else
    __local uint* key       = (__local uint*)(scratch + (MASK_KEY_INTS+MASK_COUNTER_INTS)*get_local_id(0));
    __local uchar* counters = (__local uchar*)(key + MASK_KEY_INTS);
#endif
    // config.h is making this assumption...lets check it
    if (sizeof(get_global_id(0)) != sizeof(ulong))
        return;

    const uint outOffset = get_global_id(0)*LOOP_COUNT;

    ulong index = sequenceIndex;
    index += outOffset;
    keys += outOffset*MASK_KEY_INTS;

#if LOOP_COUNT==1
    singleKey(key, index, mask);
    for (uint i = 0; i < MASK_KEY_INTS; ++i)
        keys[i] = key[i];
#else
    maskedKey(key, counters, index, mask);
    for (uint j = 0; j < LOOP_COUNT; j++)
    {
        for (uint i = 0; i < MASK_KEY_INTS; i++)
            keys[i] = key[i];

        nextMaskedKey(key, counters, mask);
        keys += MASK_KEY_INTS;
    }
#endif
}
